<head>
	<link rel = "stylesheet" href= "../style.css"> 
</head> 

<title>HackTheBox Sherlock Writeups: Loggy and Heartbreak-Continuum</title>

<a href = "../index.html" id = "back"> &#8672 ../ </a>

<body id = "blog">
	<h2>HackTheBox Sherlock Writeups</h2>
	<blockquote>I recently got into doing sherlocks because I got a blue team internship so I reckoned I should try to do something more relevant for it. Honestly, I'm not sure if it'll help with my working skills but whatever, they're pretty fun and I honestly think I like them more than HTB's regular labs!</blockquote>

	<i>Also, before we start with literally anything, make sure to unzip and run all malware files in an isolated VM. If you'd like to try this sherlock yourself, you can use this link <a href = "https://app.hackthebox.com/sherlocks/Loggy">here.</a></i>
	<br><br><br>

	<h3> &#8674 [Easy] Loggy - Malware Analysis</h3>
	<blockquote>Sherlock Scenario: Janice from accounting is beside herself! She was contacted by the SOC to tell her that her work credentials were found on the dark web by the threat intel team. We managed to recover some files from her machine and sent them to the our REM analyst.</blockquote>
	<p>At the time of writing this, there was only one other writeup for this sherlock that I found, and it was on breachforums! The writeup was really helpful too, and I'll give them credit for introducing me to the Golang Analyzer Extention that we'll use later and saved me a lot of time. So thank you, maggi from breachforums!</p>
	<p>We're given a zip file, which can be unzipped using the password given by hackthebox. Unzip it and read DANGER.txt to figure out how to get the malware binary. Once you get the binary (Loggy.exe), you're ready to go!</p>
	<p>After unzipping everything, you should be able to tell easily that this is a keylogger. I mean, there is literally a file called keylog.txt right there. There are also a couple of screenshots of a windows desktop here.</p>
	<br>

	<h4>[Task 1] What is the SHA-256 hash of this malware binary?</h4>
	<p>Just use the sha256sum command on the binary to get the hash.</p>

	<br>
	<div id = "dash">
		<blockquote id = "code">
> sha256sum Loggy.exe 
6acd8a362def62034cbd011e6632ba5120196e2011c83dc6045fcb28b590457c  Loggy.exe
		</blockquote>
	</div>

	<br>
	<h4>[Task 2] What programming language (and version) is this malware written in?</h4>
	<p>If you just strings the whole binary, you can already see evidence that the malware was written in Go (lots of references to Golang). You can scroll through the whole strings output to find the version, but (to skip a few wasted hours trying to optimise my grep output) let's just import the file in Ghidra, which will give us our answer after importing.</p>
	<p>You should see a window like this after importing. If you've already imported the program, you can go back to the first Ghidra screen, right click Loggy.exe>About program. Scroll to the bottom to get the version</p>

	<img id = "center" src = "../assets/loggyghidra1.png">

	<br>
	<h4>[Task 3] There are multiple GitHub repos referenced in the static strings. Which GitHub repo would be most likely suggest the ability of this malware to exfiltrate data?</h4>
	<p>To look through the static strings, you can either use the strings command and pipe the output to grep to look for strings containing 'github'. Or you can use the search strings function in Ghidra and filter to look for 'github'.</p>
	<p>Either way you should find a repo containing the word 'ftp'. FTP is sussy because it's used to send files, and in the context of malware this would definitely be used for exfiltration. So this would be the repo that we're looking for -> github.com/jlaffaye/ftp</p>

	<br>
	<h4>What dependency, expressed as a GitHub repo, supports Janice’s assertion that she thought she downloaded something that can just take screenshots?</h4>
	<p>Use your preferred method of searching through strings containing 'github', like the last task. You should find 'github.com/kbinani/screenshot' easily!</p>

	<br>
	<h4>[Task 5] Which function call suggests that the malware produces a file after execution?</h4>
	<p>This is where the <a href = "https://github.com/mooncat-greenpy/Ghidra_GolangAnalyzerExtension">Ghidra Golang Analyzer Extension</a> comes in. You can use it to analyse the binary, the open the extension window to see lists of the Go functions, filenames, and datatypes. I looked through the function list and filtered to find matches with the string 'file'. I found a match that fit the description of the task the most, which is the answer.</p>

	<img id = "center" src = "../assets/loggyghidra2.png">

	<br>
	<h4>[Task 6] You observe that the malware is exfiltrating data over FTP. What is the domain it is exfiltrating data to?</h4>
	<p>You can either grep this with regex (yes, I tried and I got it), but the  more elegant solution is to look through the Ghidra decompiled code.</p>
	<p>In the same Golang Analyzer window, we can filter to look through all the main functions. The function to look for is main.sendFilesOverFTP. Check that function out in the decompile view and you'll be able to see a nice and pretty domain to submit.</p>

	<img id = "center" src = "../assets/loggyghidra3.png">

	<br>
	<h4>[Task 7] What are the threat actor’s credentials?</h4>
	<p>Look at the same function (main.sendFilesOverFTP) and scroll down a bit. There's a login method, and the attacker left their credentials here in cleartext.</p>

	<img id = "center" src = "../assets/loggyghidra4.png">

	<br>
	<h4>[Task 8] What file keeps getting written to disk?</h4>
	<p>If you look through both the main.sendFilesOverFTP and main.main functions, you can see a file called keylog.txt being opened and written to repeatedly. This is the file where the keystrokes are stored. And I'm pretty sure that's the same keylog file we have now.</p>

	<br>
	<h4>[Task 9] When Janice changed her password, this was captured in a file. What is Janice's username and password?</h4>
	<p>Look through keylog.txt to get this.</p>

	<br>
	<h4>[Task 10] What app did Janice have open the last time she ran the "screenshot app"?</h4>
	<p>I was super confused when I read this, thinking there was a hidden forensics challenge in this easy malware analysis room. But don't overthink like I did. Remember the screenshots in the folder earlier? The keylogger actually does have screenshot functions (hence the screenshot github repo we found earlier). Look through the screenshots to find the answer. Janice was really playing Solitaire at work LOL.</p>

	<br><br>
	<h3> &#8674 [Easy] Loggy - Malware Analysis</h3>
	<blockquote>Sherlock Scenario: Following a recent report of a data breach at their company, the client submitted a potentially malicious executable file. The file originated from a link within a phishing email received by a victim user. Your objective is to analyze the binary to determine its functionality and possible consequences it may have on their network. By analyzing the functionality and potential consequences of this binary, you can gain valuable insights into the scope of the data breach and identify if it facilitated data exfiltration. Understanding the binary's capabilities will enable you to provide the client with a comprehensive report detailing the attack methodology, potential data at risk, and recommended mitigation steps.</blockquote>
	<p>We're given a zip file, which can be unzipped using the password given by hackthebox. Unzip it to get Superstar_MemberCard.tiff.exe.</p>
	<br>

	<br>
	<h4>[Task 1] To accurately reference and identify the suspicious binary, please provide its SHA256 hash.</h4>
	<p>Note taken: always get the hash of your binary before analysis.</p>
	
	<br>
	<div id = "dash">
		<blockquote id = "code">
> sha256sum Superstar_MemberCard.tiff.exe 
12daa34111bb54b3dcbad42305663e44e7e6c3842f015cccbbe6564d9dfd3ea3  Superstar_MemberCard.tiff.exe
		</blockquote>
	</div>

	<br>
	<h4>[Task 2] When was the binary file originally created, according to its metadata (UTC)?</h4>
	<p>You can get this with exiftool, under the Time Stamp field (if you use this method, remember to convert to UTC!) Otherwise, on a linux machine you can use the readpe command to get a lot of information about this binary. Alternatively on windows, you can use pestudio.</p>
	<br>
	<div id = "dash">
		<blockquote id = "code">
> readpe Superstar_MemberCard.tiff.exe (skipped some output)
COFF/File header
	    Machine:                         0x14c IMAGE_FILE_MACHINE_I386
	    Number of sections:              3
	    Date/time stamp:                 1710326286 (Wed, 13 Mar 2024 10:38:06 UTC)
		</blockquote>
	</div>

	<br>
	<h4>[Task 3] Examining the code size in a binary file can give indications about its functionality. Could you specify the byte size of the code in this binary?</h4>
	<p>I was a bit confused about the wording in this question, but they were talking about the literal code size. Code is stored in the .text section in a binary. Luckily, the output of readpe also shows us the size of each of the sections, in bytes. We want the raw data size.</p>
	<br>
	<div id = "dash">
		<blockquote id = "code">
Sections
    Section
            Name:                            .text
	    Virtual Size:                    0x9514 (38164 bytes)
	    Virtual Address:                 0x2000
	    Size Of Raw Data:                0x9600 (38400 bytes)
		</blockquote>
	</div>

	<br>
	<h4>[Task 4] It appears that the binary may have undergone a file conversion process. Could you determine its original filename?</h4>
	<p>Before attempting the tasks, I strings'd the binary out of habit. At the bottom of the strings output, there's a 'newILY.ps1' string. It immediately stood out being a powershell script, and also because it was very similar to the notorious ILOVEYOU computer worm. And sure enough, it's the original filename.</p>
	<p>If you look through the strings output some more, you should see a huge block of obfuscated text.</p>
	<br>
	<div id = "dash">
		<blockquote id = "code">
> strings Superstar_MemberCard.tiff.exe (skipped some output)
$sCrt = "==gCNU2Yy9mRtASZzJXdjVmUtAicpREdldmchRHJggGdhBVLg0WZ0lULlZ3btVmUK0QZjJ3bG1CIlNnc1NWZS1CIoRXYQR3YhJHd4V0dkACa0FGUtASblRXStUmdv1WZSpQDK0QfK0QKoQmblNlLtVGdJxWah1GJgACIgoQDsxWduRCI+ASKowGbBVmds92clJlLzRnbllGcpNWZS5SblRXSslWYtRCIgACIK0gCN0HIgACIK0wQDJEbvpjOdVGc5RFduVWawl2YlJFbpFWTs9kLr92bsRXdP5CcvJXZ05WSuU2YpZmZP5Cdm92cvJ3Yp10Wg0DIlBXeU5CduVWawl2YlJ1YjJGJgACIgACIgAiCNkiIzNXZyRGZBBCbpFWbFJiL0NWY052bjRCKkRWQuMHduVWawl2YlJlLtVGdJxWah1GJg0DI05WZ...
		</blockquote>
	</div>
	<p>This is definitely base 64, and probably contains the payload of this program. If you got excited like me and immediately tried to decode it, you'd see that your output would be meaningless:</p>

	<img id = "center" src = "../assets/heartbreakCcyberchef1.png">
	
	<p>We'll save this for the next task.</p>

	<br>
	<h4>[Task 5] Specify the hexadecimal offset where the obfuscated code of the identified original file begins in the binary.</h4>
	<p>We've already found the obfuscated code, so now we gotta look for the hex offset. You can use the hex editor of your choice to look at the binary. I used hexedit to do this. The hex offset's on the furthest column to the left (2C74).</p>

	<img id = "center" src = "../assets/heartbreakChexedit.png">

</body>

